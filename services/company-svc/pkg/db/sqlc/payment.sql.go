// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: payment.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createPayment = `-- name: CreatePayment :one
INSERT INTO 
  company.payment (
    company_id,
    name,
    bank,
    account_number,
    account_type,
    identification_number,
    identification_type,
    phone,
    email,
    payment_type_id,
    is_active
  ) 
VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, TRUE 
) 
RETURNING id, company_id, name, bank, account_number, account_type, identification_number, identification_type, phone, email, payment_type_id, created_at, modified_at, is_active
`

type CreatePaymentParams struct {
	CompanyID            int64          `json:"company_id"`
	Name                 string         `json:"name"`
	Bank                 sql.NullString `json:"bank"`
	AccountNumber        sql.NullString `json:"account_number"`
	AccountType          sql.NullString `json:"account_type"`
	IdentificationNumber sql.NullString `json:"identification_number"`
	IdentificationType   sql.NullString `json:"identification_type"`
	Phone                sql.NullString `json:"phone"`
	Email                sql.NullString `json:"email"`
	PaymentTypeID        int64          `json:"payment_type_id"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (CompanyPayment, error) {
	row := q.db.QueryRowContext(ctx, createPayment,
		arg.CompanyID,
		arg.Name,
		arg.Bank,
		arg.AccountNumber,
		arg.AccountType,
		arg.IdentificationNumber,
		arg.IdentificationType,
		arg.Phone,
		arg.Email,
		arg.PaymentTypeID,
	)
	var i CompanyPayment
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.Bank,
		&i.AccountNumber,
		&i.AccountType,
		&i.IdentificationNumber,
		&i.IdentificationType,
		&i.Phone,
		&i.Email,
		&i.PaymentTypeID,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.IsActive,
	)
	return i, err
}

const deletePayment = `-- name: DeletePayment :exec
DELETE FROM 
  company.payment
WHERE 
  id = $1
`

func (q *Queries) DeletePayment(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deletePayment, id)
	return err
}

const getPayment = `-- name: GetPayment :one
SELECT 
  P.id,
  P.company_id,
  P.name,
  P.bank,
  P.account_number,
  P.account_type,
  P.identification_number,
  P.identification_type,
  P.phone,
  P.email,
  P.payment_type_id,
  P.is_active,
  P.created_at,
  P.modified_at,
  pt.id, pt.name, pt.created_at, pt.modified_at, pt.image_path
FROM 
  company.payment AS P
INNER JOIN 
  company.payment_type AS PT ON P.payment_type_id = PT.id
WHERE 
  P.id = $1 
LIMIT 1
`

type GetPaymentRow struct {
	ID                   int64              `json:"id"`
	CompanyID            int64              `json:"company_id"`
	Name                 string             `json:"name"`
	Bank                 sql.NullString     `json:"bank"`
	AccountNumber        sql.NullString     `json:"account_number"`
	AccountType          sql.NullString     `json:"account_type"`
	IdentificationNumber sql.NullString     `json:"identification_number"`
	IdentificationType   sql.NullString     `json:"identification_type"`
	Phone                sql.NullString     `json:"phone"`
	Email                sql.NullString     `json:"email"`
	PaymentTypeID        int64              `json:"payment_type_id"`
	IsActive             bool               `json:"is_active"`
	CreatedAt            time.Time          `json:"created_at"`
	ModifiedAt           time.Time          `json:"modified_at"`
	CompanyPaymentType   CompanyPaymentType `json:"company_payment_type"`
}

func (q *Queries) GetPayment(ctx context.Context, id int64) (GetPaymentRow, error) {
	row := q.db.QueryRowContext(ctx, getPayment, id)
	var i GetPaymentRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.Bank,
		&i.AccountNumber,
		&i.AccountType,
		&i.IdentificationNumber,
		&i.IdentificationType,
		&i.Phone,
		&i.Email,
		&i.PaymentTypeID,
		&i.IsActive,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.CompanyPaymentType.ID,
		&i.CompanyPaymentType.Name,
		&i.CompanyPaymentType.CreatedAt,
		&i.CompanyPaymentType.ModifiedAt,
		&i.CompanyPaymentType.ImagePath,
	)
	return i, err
}

const getPayments = `-- name: GetPayments :many
SELECT 
  P.id,
  P.company_id,
  P.name,
  P.bank,
  P.account_number,
  P.account_type,
  P.identification_number,
  P.identification_type,
  P.phone,
  P.email,
  P.payment_type_id,
  P.is_active,
  P.created_at,
  P.modified_at,
  pt.id, pt.name, pt.created_at, pt.modified_at, pt.image_path
FROM 
  company.payment AS P
INNER JOIN 
  company.payment_type AS PT ON P.payment_type_id = PT.id
WHERE
  ((P.company_id = $1) OR $1 = 0) AND
  ((P.payment_type_id = $2) OR $2 = 0)
ORDER BY 
  P.id
LIMIT 
  $3
OFFSET 
  $4
`

type GetPaymentsParams struct {
	CompanyID     int64 `json:"company_id"`
	PaymentTypeID int64 `json:"payment_type_id"`
	Limit         int32 `json:"limit"`
	Offset        int32 `json:"offset"`
}

type GetPaymentsRow struct {
	ID                   int64              `json:"id"`
	CompanyID            int64              `json:"company_id"`
	Name                 string             `json:"name"`
	Bank                 sql.NullString     `json:"bank"`
	AccountNumber        sql.NullString     `json:"account_number"`
	AccountType          sql.NullString     `json:"account_type"`
	IdentificationNumber sql.NullString     `json:"identification_number"`
	IdentificationType   sql.NullString     `json:"identification_type"`
	Phone                sql.NullString     `json:"phone"`
	Email                sql.NullString     `json:"email"`
	PaymentTypeID        int64              `json:"payment_type_id"`
	IsActive             bool               `json:"is_active"`
	CreatedAt            time.Time          `json:"created_at"`
	ModifiedAt           time.Time          `json:"modified_at"`
	CompanyPaymentType   CompanyPaymentType `json:"company_payment_type"`
}

func (q *Queries) GetPayments(ctx context.Context, arg GetPaymentsParams) ([]GetPaymentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPayments,
		arg.CompanyID,
		arg.PaymentTypeID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPaymentsRow{}
	for rows.Next() {
		var i GetPaymentsRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.Name,
			&i.Bank,
			&i.AccountNumber,
			&i.AccountType,
			&i.IdentificationNumber,
			&i.IdentificationType,
			&i.Phone,
			&i.Email,
			&i.PaymentTypeID,
			&i.IsActive,
			&i.CreatedAt,
			&i.ModifiedAt,
			&i.CompanyPaymentType.ID,
			&i.CompanyPaymentType.Name,
			&i.CompanyPaymentType.CreatedAt,
			&i.CompanyPaymentType.ModifiedAt,
			&i.CompanyPaymentType.ImagePath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsTypes = `-- name: GetPaymentsTypes :many
SELECT 
  P.id,
  P.company_id,
  P.payment_type_id,
  P.is_active,
  pt.id, pt.name, pt.created_at, pt.modified_at, pt.image_path
FROM 
  company.payment AS P
INNER JOIN 
  company.payment_type AS PT ON P.payment_type_id = PT.id
WHERE
  P.company_id = $1 OR $1 = 0
ORDER BY 
  P.id
`

type GetPaymentsTypesRow struct {
	ID                 int64              `json:"id"`
	CompanyID          int64              `json:"company_id"`
	PaymentTypeID      int64              `json:"payment_type_id"`
	IsActive           bool               `json:"is_active"`
	CompanyPaymentType CompanyPaymentType `json:"company_payment_type"`
}

func (q *Queries) GetPaymentsTypes(ctx context.Context, companyID int64) ([]GetPaymentsTypesRow, error) {
	rows, err := q.db.QueryContext(ctx, getPaymentsTypes, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPaymentsTypesRow{}
	for rows.Next() {
		var i GetPaymentsTypesRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.PaymentTypeID,
			&i.IsActive,
			&i.CompanyPaymentType.ID,
			&i.CompanyPaymentType.Name,
			&i.CompanyPaymentType.CreatedAt,
			&i.CompanyPaymentType.ModifiedAt,
			&i.CompanyPaymentType.ImagePath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePayment = `-- name: UpdatePayment :one
UPDATE 
  company.payment
SET 
  name = $2,
  bank = $3,
  account_number = $4,
  account_type = $5,
  identification_number = $6,
  identification_type = $7,
  phone = $8,
  email = $9,
  payment_type_id = $10,  
  modified_at = NOW()
WHERE 
  id = $1
RETURNING id, company_id, name, bank, account_number, account_type, identification_number, identification_type, phone, email, payment_type_id, created_at, modified_at, is_active
`

type UpdatePaymentParams struct {
	ID                   int64          `json:"id"`
	Name                 string         `json:"name"`
	Bank                 sql.NullString `json:"bank"`
	AccountNumber        sql.NullString `json:"account_number"`
	AccountType          sql.NullString `json:"account_type"`
	IdentificationNumber sql.NullString `json:"identification_number"`
	IdentificationType   sql.NullString `json:"identification_type"`
	Phone                sql.NullString `json:"phone"`
	Email                sql.NullString `json:"email"`
	PaymentTypeID        int64          `json:"payment_type_id"`
}

func (q *Queries) UpdatePayment(ctx context.Context, arg UpdatePaymentParams) (CompanyPayment, error) {
	row := q.db.QueryRowContext(ctx, updatePayment,
		arg.ID,
		arg.Name,
		arg.Bank,
		arg.AccountNumber,
		arg.AccountType,
		arg.IdentificationNumber,
		arg.IdentificationType,
		arg.Phone,
		arg.Email,
		arg.PaymentTypeID,
	)
	var i CompanyPayment
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.Bank,
		&i.AccountNumber,
		&i.AccountType,
		&i.IdentificationNumber,
		&i.IdentificationType,
		&i.Phone,
		&i.Email,
		&i.PaymentTypeID,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.IsActive,
	)
	return i, err
}

const updatePaymentStatus = `-- name: UpdatePaymentStatus :one
UPDATE 
  company.payment
SET 
  is_active = $2,
  modified_at = NOW()
WHERE 
  id = $1
RETURNING id, company_id, name, bank, account_number, account_type, identification_number, identification_type, phone, email, payment_type_id, created_at, modified_at, is_active
`

type UpdatePaymentStatusParams struct {
	ID       int64 `json:"id"`
	IsActive bool  `json:"is_active"`
}

func (q *Queries) UpdatePaymentStatus(ctx context.Context, arg UpdatePaymentStatusParams) (CompanyPayment, error) {
	row := q.db.QueryRowContext(ctx, updatePaymentStatus, arg.ID, arg.IsActive)
	var i CompanyPayment
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.Bank,
		&i.AccountNumber,
		&i.AccountType,
		&i.IdentificationNumber,
		&i.IdentificationType,
		&i.Phone,
		&i.Email,
		&i.PaymentTypeID,
		&i.CreatedAt,
		&i.ModifiedAt,
		&i.IsActive,
	)
	return i, err
}
